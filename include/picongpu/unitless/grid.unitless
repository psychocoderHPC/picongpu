/* Copyright 2013-2020 Felix Schmitt, Heiko Burau, Rene Widera,
 *                     Benjamin Worpitz
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */



#pragma once

#include <pmacc/math/Vector.hpp>

namespace picongpu
{
    CREATE_GLOBAL_VAR(float3_X, cellSize, PIC);
    DEF_GLOBAL_VAR(float3_64, cellSize, CELL_WIDTH.unit(), [=](auto x)
    {
        x.x() = CELL_WIDTH(base::SI);
        x.y() = CELL_HEIGHT(base::SI);
        x.z() = CELL_DEPTH(base::SI);
        return x;
    });

    GLOBAL_VAR_CONVERSION(cellSize, PIC, [=](auto x)
    {
        for (int i = 0; i < cellSize(base::SI).dim; ++i)
            x[i] = cellSize(base::SI)[i] * cellSize.sfactor(base::SI, base::PIC);
        return x;
    });

    // only used for CFL checks
    CREATE_GLOBAL_VAR(float_X, INV_CELL2_SUM, PIC);
    DEF_GLOBAL_VAR(float_64, INV_CELL2_SUM, units::scalar, [=](auto tmp)
    {
        tmp = 0.;
        for(uint32_t d = 0u; d < simDim; ++d)
            tmp += 1.0 / (cellSize(base::SI)[d] * cellSize(base::SI)[d]);
        return tmp;
    });

    GLOBAL_VAR_CONVERSION(INV_CELL2_SUM, PIC, [=](auto tmp)
    {
        tmp = 0.0;
        for(uint32_t d = 0u; d < simDim; ++d)
            tmp += 1.0 / (cellSize(base::PIC)[d] * cellSize(base::PIC)[d]);
        return tmp;
    });

    CREATE_GLOBAL_VAR(float_X, CELL_VOLUME, PIC);
    DEF_GLOBAL_VAR(float_64, CELL_VOLUME, units::scalar, [=](auto tmp)
    {
        return cellSize(base::SI).productOfComponents();
    });

    GLOBAL_VAR_CONVERSION(CELL_VOLUME, PIC, [=](auto tmp)
    {
        return cellSize(base::PIC).productOfComponents();
    });

#if 0
    // normed grid parameter


    UNIT_BASE(UNIT_TIME, PIC, [&]()
    {
        return DELTA_T(base::SI);
    });

    UNIT_BASE(UNIT_LENGTH, PIC, [&]()
    {
        return CELL_WIDTH(base::SI);
    });

    INIT(DELTA_T, PIC, [&]()
    {
        return DELTA_T(base::SI) / UNIT_TIME;
    });

    INIT(CELL_WIDTH, PIC, [&]()
    {
        return CELL_WIDTH(base::SI) / UNIT_LENGTH;
    });

    INIT(CELL_HEIGHT, PIC, [&]()
    {
        return CELL_HEIGHT(base::SI) / UNIT_LENGTH;
    });

    INIT(CELL_DEPTH, PIC, [&]()
    {
        return CELL_DEPTH(base::SI) / UNIT_LENGTH;
    });

    // always a 3D cell, even in 1D3V or 2D3V
    DEF_GLOBAL_VAR(float3_64, cellSize, [&]()
    {
        return float3_64(CELL_WIDTH(base::SI), CELL_HEIGHT(base::SI), CELL_DEPTH(base::SI));
    });
    GLOBAL_VAR_ADD(float3_X, cellSize, PIC);

    INIT(cellSize, PIC, [&]()
    {
        return cellSize(base::SI) * scale(LENGTH, base::SI, base::PIC);
    });

    // volume of a cell
    PIC_DEF_GLOBAL_VAR(float_64, CELL_VOLUME,
        (
            [&]()
            {
                return cellSize(base::SI).productOfComponents();
            }
        ),
        float_X,
        (
            [&]()
            {
                return cellSize(base::PIC).productOfComponents();
            }
        )
    );

    // only used for CFL checks
    PIC_DEF_GLOBAL_VAR(float_64, INV_CELL2_SUM,
        (
            [&]()
            {
                float_64 tmp = 0.;
                for(uint32_t d = 0u; d < simDim; ++d)
                    tmp += 1.0 / (cellSize(base::SI)[d] * cellSize(base::SI)[d]);
                return tmp;
            }
        ),
        float_X,
        (
            [&]()
            {
                float_64 tmp = 0.;
                for(uint32_t d = 0u; d < simDim; ++d)
                    tmp += 1.0 / (cellSize(base::PIC)[d] * cellSize(base::PIC)[d]);
                return static_cast<float_X>(tmp);
            }
        )
    );
#endif
}
