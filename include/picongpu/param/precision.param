/* Copyright 2013-2020 Rene Widera
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

/** @file
 *
 * Define the precision of typically used floating point types in the
 * simulation.
 *
 * PIConGPU normalizes input automatically, allowing to use single-precision by
 * default for the core algorithms. Note that implementations of various
 * algorithms (usually plugins or non-core components) might still decide to
 * hard-code a different (mixed) precision for some critical operations.
 */

#pragma once

#include <pmacc/ppFunctions.hpp>
#include <pmacc/attribute/FunctionSpecifier.hpp>
#include <list>
#include <boost/program_options.hpp>

#include "unitSystem.hpp"

#ifdef __CUDA_ARCH__
#   define CREATE_VAR(...) __device__ __VA_ARGS__
#else
#   define CREATE_VAR(...) __VA_ARGS__
#endif

namespace picongpu
{

/*! Select a precision for the simulation data
 *  - precision32Bit : use 32Bit floating point numbers
 *                     [significant digits 7 to 8]
 *  - precision64Bit : use 64Bit floating point numbers
 *                     [significant digits 15 to 16]
 */
namespace precisionPIConGPU      = precision32Bit;

/*! Select a precision special operations (can be different from simulation precision)
 *  - precisionPIConGPU : use precision which is selected on top (precisionPIConGPU)
 *  - precision32Bit    : use 32Bit floating point numbers
 *  - precision64Bit    : use 64Bit floating point numbers
 */
namespace precisionSqrt          = precisionPIConGPU;
namespace precisionExp           = precisionPIConGPU;
namespace precisionTrigonometric = precisionPIConGPU;


} // namespace picongpu

#include "picongpu/unitless/precision.unitless"

namespace picongpu
{
    PIC_DEF_CATEGORY(float_64, TIME, units::second);
#define UNIT_TIME TIME(picongpu::base::PIC, picongpu::base::SI)

    PIC_DEF_CATEGORY(float_64, LENGTH, units::meter);
#define UNIT_LENGTH LENGTH(picongpu::base::PIC, picongpu::base::SI)

    PIC_DEF_CATEGORY(float_X , MASS, units::kilogram);
#define UNIT_MASS MASS(picongpu::base::PIC, picongpu::base::SI)

    PIC_DEF_CATEGORY(float_64, CHARGE, units::ampere_hour);
#define UNIT_CHARGE CHARGE(picongpu::base::PIC, picongpu::base::SI)

    template<class T_Unit>
    struct Scale;

    template<class Units, typename T, template<typename> class NonLinearScale>
    struct Scale<::units::unit_t<Units, T, NonLinearScale>>
    {
        using X = ::units::unit_t<Units, T, NonLinearScale>;
        using UnitType = typename X::unit_type;
        template<typename U1, typename U2>
        HDINLINE auto convert(const U1 u1, const U2 u2)
        {
            return
                myPow(LENGTH(u1, u2),1.0, std::abs(UnitType::base_unit_type::meter_ratio::num))
                    * myPow(MASS(u1, u2),1.0, std::abs(UnitType::base_unit_type::kilogram_ratio::num))
                    * myPow(TIME(u1, u2),1.0, std::abs(UnitType::base_unit_type::second_ratio::num))
                    //* myPow(LENGTH(u1, u2),1.0, std::abs(UnitType::base_unit_type::radian_ratio::num))
                    * myPow(CHARGE(u1, u2),1.0, std::abs(UnitType::base_unit_type::ampere_ratio::num))
                //* myPow(LENGTH(u1, u2),1.0, std::abs(UnitType::base_unit_type::kelvin_ratio::num))
                //* myPow(LENGTH(u1, u2),1.0, std::abs(UnitType::base_unit_type::mole_ratio::num))
                //* myPow(LENGTH(u1, u2),1.0, std::abs(UnitType::base_unit_type::candela_ratio::num))
                //* myPow(LENGTH(u1, u2),1.0, std::abs(UnitType::base_unit_type::byte_ratio::num))
                ;
        }

    };

    template<typename T, typename U1, typename U2>
    HDINLINE auto scaling(T v, const U1 u1, const U2 u2)
    {
        //std::cout<<"rescale: "<<v<<std::endl;
        return Scale<T>{}.convert(u1,u2) * v;
    }

} // namespace picongpu

