/* Copyright 2013-2018 Axel Huebl, Heiko Burau, Rene Widera
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <pmacc/math/Vector.hpp>
#include <pmacc/dimensions/DataSpace.hpp>
#include <pmacc/memory/boxes/CachedBox.hpp>
#include <pmacc/nvidia/functors/Assign.hpp>

namespace picongpu
{
    /** compute the electric field of the laser
     *
     * @tparam T_numWorkers number of workers
     * @tparam T_LaserPlaneSizeInSuperCell number of cells per dimension which
     *  initialize the laser (size must be less or equal than the supercell size)
     */
    template<
        uint32_t T_numWorkers,
        typename T_LaserPlaneSizeInSuperCell
    >
    struct KernelLaser
    {
        template<
            typename EBox,
            typename T_Acc
        >
        DINLINE void operator()(
            T_Acc const & acc,
            LaserFunctor laserFunctor
        ) const
        {
            using LaserPlaneSizeInSuperCell = T_LaserPlaneSizeInSuperCell;

            PMACC_CASSERT_MSG(
                __LaserPlaneSizeInSuperCell_y_must_be_less_or_equal_than_SuperCellSize_y,
                LaserPlaneSizeInSuperCell::y::value <= SuperCellSize::y::value
            );

            constexpr uint32_t planeSize = pmacc::math::CT::volume< LaserPlaneSizeInSuperCell >::type::value;
            constexpr uint32_t numWorkers = T_numWorkers;

            const uint32_t workerIdx = threadIdx.x;

            DataSpace< simDim > const superCellIdx = mapper.getSuperCellIndex( DataSpace< simDim >( blockIdx ) );

            // offset of the superCell (in cells, without any guards) to the origin of the local domain
            DataSpace< simDim > localSuperCellOffset =
                superCellIdx - mapper.getGuardingSuperCells( );

            // add not handled supercells from laser::initPlaneY
            localSuperCellOffset.y() += laser::initPlaneY / SuperCellSize::y;

            uint32_t cellOffsetInSuperCellFromInitPlaneY = laser::initPlaneY % SuperCellSize::y;

            auto accLaserFunctor = laserFunctor(
                acc,
                localSuperCellOffset,
                WorkerCfg< numWorker >{ workerIdx }
            );

            mappings::threads::ForEachIdx<
                mappings::threads::IdxConfig<
                    planeSize,
                    numWorkers
                >
            > { workerIdx }(
                [&](
                    uint32_t const linearIdx,
                    uint32_t const
                )
                {
                    /* cell index within the superCell */
                    DataSpace< simDim > const cellIdxInSuperCell = DataSpaceOperations< simDim >::template map< LaserPlaneSizeInSuperCell >( linearIdx );
                    cellIdxInSuperCell.y() += cellOffsetInSuperCellFromInitPlaneY;

                    accLaserFunctor( cellIdxInSuperCell );
                }
            );
        }
    };

}
