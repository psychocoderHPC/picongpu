/**
 * Copyright 2014-2016 Axel Huebl, Alexander Debus
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once
#define GRID_SIZE 384
/** Load external background fields
 *
 */
namespace picongpu
{
    class FieldBackgroundE
    {
    public:
        /* Add this additional field for pushing particles */
        BOOST_STATIC_CONSTEXPR bool InfluenceParticlePusher = true;

        /* We use this to calculate your SI input back to our unit system */
        PMACC_ALIGN(m_unitField, const float3_64);

        HDINLINE FieldBackgroundE( const float3_64 unitField ) : m_unitField(unitField)
        {}

        /** Specify your background field E(r,t) here
         *
         * \param cellIdx The total cell id counted from the start at t = 0
         * \param currentStep The current time step */
        HDINLINE float3_X
        operator()( const DataSpace<simDim>& cellIdx,
                    const uint32_t currentStep ) const
        {
			//Circular wave propagation version 1
            /*
            const float_64 positionRelativeX = (cellIdx.x() - GRID_SIZE / 2);
            const float_64 positionRelativeY = (cellIdx.y() - GRID_SIZE / 2);

            float_64 sinX = 0.0;
            float_64 sinY = 0.0;
            float_64 sinT = 0.0;
            if(currentStep <= 100 && (math::abs((positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY) - (120 * 120)) < 64))
            {
                sinT = math::sin(precisionCast<float_X>( float_X(currentStep) / float_X(100.0) * float_X(2.0) * PI ));
                sinX = positionRelativeX / math::sqrt(positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY) * sinT;
                sinY = positionRelativeY / math::sqrt(positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY) * sinT;
            }*/

            //Circular wave propagation version 2
			/*
            const float_64 positionRelativeX = (cellIdx.x() - GRID_SIZE / 2);
            const float_64 positionRelativeY = (cellIdx.y() - GRID_SIZE / 2);
	        const float_64 radius = math::sqrt(positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY);

            float_64 sin = 0.0;

            if(currentStep == 0 && radius >= 50 && radius <= 100)
            {
                sin = math::sin(precisionCast<float_X>(radius / 50 * float_X(2.0) * PI));
            }
			*/
	        //Circular wave propagation 3D

	        float_64 Er = 0.0;
	        float_64 Ex = 0.0;
	        float_64 Ey = 0.0;
	        float_64 Ez = 0.0;

	        const float_64 positionRelativeX = (cellIdx.x() - GRID_SIZE / 2);
	        const float_64 positionRelativeY = (cellIdx.y() - GRID_SIZE / 2);
	        const float_64 positionRelativeZ = (cellIdx.z() - GRID_SIZE / 2);
	        const float_64 radius = math::sqrt(positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY + positionRelativeZ * positionRelativeZ);

	        if(currentStep == 0 && radius >= 50 && radius <= 100)
	        {
		        Er = math::sin(precisionCast<float_X>(radius / 50 * float_X(2.0) * PI));

		        if(positionRelativeX != 0 || positionRelativeY != 0)
		        {
			        Ex = Er *
			             math::sqrt(positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY) /
			             radius
			             * positionRelativeX /
			             math::sqrt(positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY);

			        Ey = Er *
			             math::sqrt(positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY) /
			             radius
			             * positionRelativeY /
			             math::sqrt(positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY);
		        }
		        Ez = Er * positionRelativeZ / radius;
	        }

	        //Plane wave propagation in x/y direction
			/*
	        float_64 sinX = 0.0;

	        //const float_64 positionRelativeX = (cellIdx.x() - GRID_SIZE / 2);
	        //const float_64 positionRelativeY = (cellIdx.y() - GRID_SIZE / 2);
	        const float_64 positionRelativeZ = (cellIdx.z() - GRID_SIZE / 2);

	        if(currentStep == 0 && math::abs(positionRelativeZ) <= 50)
			{
				sinX = math::sin(precisionCast<float_X>(positionRelativeZ / float_X(100.0) * float_X(2.0) * PI ));
			}
			*/
	        /* specify your E-Field in V/m and convert to PIConGPU units */
            return float3_X(Ex / m_unitField[0], Ey / m_unitField[1], Ez / m_unitField[2]);
        }
    };

    class FieldBackgroundB
    {
    public:
        /* Add this additional field for pushing particles */
        BOOST_STATIC_CONSTEXPR bool InfluenceParticlePusher = true;

        /* We use this to calculate your SI input back to our unit system */
        PMACC_ALIGN(m_unitField, const float3_64);

        HDINLINE FieldBackgroundB( const float3_64 unitField ) : m_unitField(unitField)
        {}

        /** Specify your background field B(r,t) here
         *
         * \param cellIdx The total cell id counted from the start at t=0
         * \param currentStep The current time step */
        HDINLINE float3_X
        operator()( const DataSpace<simDim>& cellIdx,
                    const uint32_t currentStep ) const
        {
	        //Circular wave propagation version 1
            /*
            const float_64 positionRelativeX = (cellIdx.x() - GRID_SIZE / 2);
            const float_64 positionRelativeY = (cellIdx.y() - GRID_SIZE / 2);

            float_64 sinT = 0.0;

	        if(currentStep <= 100 && (math::abs((positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY) - (120 * 120)) < 64))
	        {
                sinT = math::sin(precisionCast<float_X>( float_X(currentStep) / float_X(100.0) * float_X(2.0) * PI ));
            }*/

            //Circular wave propagation version 2
			/*
            const float_64 positionRelativeX = (cellIdx.x() - GRID_SIZE / 2);
            const float_64 positionRelativeY = (cellIdx.y() - GRID_SIZE / 2);
	        const float_64 positionRelativeZ = (cellIdx.z() - GRID_SIZE / 2);
            const float_64 radius = math::sqrt(positionRelativeX * positionRelativeX + positionRelativeY * positionRelativeY + positionRelativeZ * positionRelativeZ);

            float_64 sin = 0.0;

            if(currentStep == 0 && radius >= 50 && radius <= 100)
            {
                sin = math::sin(precisionCast<float_X>(radius / 50 * float_X(2.0) * PI));
            }
			*/
	        //Plane wave propagation in x/y direction
			/*
	        float_64 sinX = 0.0;
	        float_64 sinT = 0.0;

	        //const float_64 positionRelativeX = (cellIdx.x() - GRID_SIZE / 2);
	        //const float_64 positionRelativeY = (cellIdx.y() - GRID_SIZE / 2);
	        const float_64 positionRelativeZ = (cellIdx.z() - GRID_SIZE / 2);

	        if(currentStep == 0 && math::abs(positionRelativeZ) <= 50)
	        {
		        //sinT = math::sin(precisionCast<float_X>( float_X(currentStep) / float_X(100.0) * float_X(2.0) * PI ));
		        sinT = float_X(1.0);
		        sinX = sinT * math::sin(precisionCast<float_X>(positionRelativeZ / float_X(100.0) * float_X(2.0) * PI ));
	        }
			*/
            return float3_X(0.0, 0.0, 0.0);
        }
    };

    class FieldBackgroundJ
    {
    public:
        /* Add this additional field? */
        BOOST_STATIC_CONSTEXPR bool activated = false;

        /* We use this to calculate your SI input back to our unit system */
        PMACC_ALIGN(m_unitField, const float3_64);

        HDINLINE FieldBackgroundJ( const float3_64 unitField ) : m_unitField(unitField)
        {}

        /** Specify your background field J(r,t) here
         *
         * \param cellIdx The total cell id counted from the start at t=0
         * \param currentStep The current time step */
        HDINLINE float3_X
        operator()( const DataSpace<simDim>& cellIdx,
                    const uint32_t currentStep ) const
        {
            /* example: periodicity of 20 microns ( = 2.0e-5 m) */
            BOOST_CONSTEXPR_OR_CONST float_64 period_SI(20.0e-6);
            /* calculate cells -> SI -> m to microns*/
            const float_64 y_SI = cellIdx.y() * SI::CELL_HEIGHT_SI * 1.0e6;
            /* note: you can also transform the time step to seconds by
             *       multiplying with DELTA_T_SI */

            /* specify your J-Field in A/m^2 and convert to PIConGPU units */
            const float_X sinArg = precisionCast<float_X>( y_SI / period_SI * 2.0 * PI );
            return float3_X(0.0, math::cos( sinArg ) / m_unitField[1], 0.0);
        }
    };

} // namespace picongpu
