/* Copyright 2014-2017 Rene Widera, Alexander Grund
 *
 * This file is part of libPMacc.
 *
 * libPMacc is free software: you can redistribute it and/or modify
 * it under the terms of either the GNU General Public License or
 * the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * libPMacc is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License and the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License
 * and the GNU Lesser General Public License along with libPMacc.
 * If not, see <http://www.gnu.org/licenses/>.
 */


#pragma once

#include "pmacc_types.hpp"
#include "traits/GetNumWorker.hpp"
#include "dimensions/DataSpaceOperations.hpp"
#include "math/Vector.hpp"
#include "particles/frame_types.hpp"
#include "nvidia/atomic.hpp"
#include "debug/VerboseLog.hpp"
#include "memory/shared/Allocate.hpp"
#include "memory/Array.hpp"
#include "memory/CtxArray.hpp"
#include "mappings/threads/ForEachIdx.hpp"
#include "mappings/threads/IdxConfig.hpp"

namespace PMacc
{
namespace particles
{
namespace operations
{
namespace kernel
{
    template< uint32_t T_worker >
    struct SplitIntoListOfFrames
    {
        /** Copy particles from big frame to PMacc frame structure
         *  (Opposite to ConcatListOfFrames)
         *
         * - convert a user-defined domainCellIdx to localCellIdx
         * - processed particles per block <= number of cells per superCell
         *
         * @param counter box with three integer [srcParticleOffset, numLoadedParticles, numUsedFrames]
         * @param destBox particle box were all particles are copied to (destination)
         * @param srcFrame frame with particles (is used as source)
         * @param maxParticles number of particles in srcFrame
         * @param localDomainCellOffset offset in cells to user-defined domain (@see wiki PIConGPU domain definitions)
         * @param domainCellIdxIdentifier the identifier for the particle domain cellIdx
         *                                that is calculated back to the local domain
         *                                with respect to localDomainCellOffset
         * @param cellDesc picongpu cellDescription
         */
        template<class T_CounterBox, class T_DestBox, class T_SrcFrame, class T_Space, class T_Identifier, class T_CellDescription>
        DINLINE void operator()(
            T_CounterBox counter,
            T_DestBox destBox,
            T_SrcFrame srcFrame,
            const int maxParticles,
            const T_Space localDomainCellOffset,
            const T_Identifier domainCellIdxIdentifier,
            const T_CellDescription cellDesc
        ) const
        {
            using namespace PMacc::particles::operations;
            using namespace mappings::threads;

            typedef T_SrcFrame SrcFrameType;
            typedef typename T_DestBox::FrameType DestFrameType;
            typedef typename T_DestBox::FramePtr DestFramePtr;
            typedef typename T_CellDescription::SuperCellSize SuperCellSize;
            constexpr unsigned dim = T_DestBox::Dim;
            constexpr uint32_t particlesPerFrame = PMacc::math::CT::volume<SuperCellSize>::type::value;
            constexpr uint32_t numWorker = T_worker;

            PMACC_SMEM( destFramePtr, memory::Array< DestFramePtr, particlesPerFrame > );
            PMACC_SMEM( linearSuperCellIds, memory::Array< int, particlesPerFrame > );
            PMACC_SMEM( srcParticleOffset, int );


            uint32_t const workerIdx = threadIdx.x;

            DataSpace< dim > const numSuperCells( cellDesc.getGridSuperCells() - cellDesc.getGuardingSuperCells() * 2 );

            ForEachIdx<
                IdxConfig<
                    1,
                    numWorker
                >
            >{ workerIdx }(
                [&]( uint32_t const, uint32_t const )
                {
                    /* apply for work for the full block
                     * counter [0] -> offset to load particles
                     */
                    srcParticleOffset = atomicAdd( &( counter[ 0 ] ), particlesPerFrame );
                }
            );

            using ParticleDomCfg = IdxConfig<
                particlesPerFrame,
                numWorker
            >;
            /* loop over all particles in the frame */
            ForEachIdx< ParticleDomCfg > forEachParticle( workerIdx );

            forEachParticle(
                [&]( uint32_t const linearIdx, uint32_t const )
                {
                    destFramePtr[ linearIdx ] = DestFramePtr( );
                    linearSuperCellIds[ linearIdx ] = -1;
                }
            );

            __syncthreads();

            memory::CtxArray<
                int,
                ParticleDomCfg
            > const
            srcParticleIdxCtx(
                workerIdx,
                [&]( uint32_t const linearIdx, uint32_t const ) -> int{
                    return srcParticleOffset + linearIdx;
                }
            );

            memory::CtxArray<
                bool,
                ParticleDomCfg
            > const
            hasValidParticleCtx(
                workerIdx,
                [&]( uint32_t const linearIdx, uint32_t const idx ) -> bool{
                    return srcParticleIdxCtx[ idx ] < maxParticles;
                }
            );

            memory::CtxArray<
                DataSpace< dim >,
                ParticleDomCfg
            >
            superCellIdxCtx;

            memory::CtxArray<
                lcellId_t,
                ParticleDomCfg
            >
            lCellIdxCtx( INV_LOC_IDX );

            memory::CtxArray<
                int,
                ParticleDomCfg
            >
            myLinearSuperCellIdCtx( -1 );

            forEachParticle(
                [&]( uint32_t const linearIdx, uint32_t const idx )
                {
                    if( hasValidParticleCtx[ idx ] )
                    {
                        // cell index on this GPU
                        DataSpace< dim > const gpuCellIdx = srcFrame[ srcParticleIdxCtx[ idx ] ][ domainCellIdxIdentifier ]
                                                                 - localDomainCellOffset;
                        superCellIdxCtx[ idx ] = gpuCellIdx / SuperCellSize::toRT();
                        myLinearSuperCellIdCtx[ idx ] = DataSpaceOperations< dim >::map(
                            numSuperCells,
                            superCellIdxCtx[ idx ]
                        );
                        linearSuperCellIds[ linearIdx ] = myLinearSuperCellIdCtx[ idx ];
                        DataSpace< dim > localCellIdx( gpuCellIdx - superCellIdxCtx[ idx ] * SuperCellSize::toRT() );
                        lCellIdxCtx[ idx ] = DataSpaceOperations< dim >::template map< SuperCellSize >( localCellIdx );
                    }
                }
            );

            __syncthreads();

            memory::CtxArray<
                int,
                ParticleDomCfg
            >
            masterIdxCtx(
                workerIdx,
                [&]( uint32_t const linearIdx, uint32_t const ) -> int{
                    return linearIdx - 1;
                }
            );


            forEachParticle(
                [&]( uint32_t const linearIdx, uint32_t const idx )
                {
                    if( hasValidParticleCtx[ idx ] )
                    {
                        /* search master thread index */
                        while( masterIdxCtx[ idx ] >= 0 )
                        {
                            if( myLinearSuperCellIdCtx[ idx ] != linearSuperCellIds[ masterIdxCtx[ idx ] ] )
                                break;
                            --masterIdxCtx[ idx ];
                        }
                        ++masterIdxCtx[ idx ];
                        /* load empty frame if thread is the master*/
                        if( masterIdxCtx[ idx ] == linearIdx )
                        {
                            /* counter[2] -> number of used frames */
                            nvidia::atomicAllInc( &( counter[2] ) );
                            DestFramePtr tmpFrame = destBox.getEmptyFrame( );
                            destFramePtr[ linearIdx ] = tmpFrame;
                            destBox.setAsFirstFrame(
                                tmpFrame,
                                superCellIdxCtx[ idx ] +
                                    cellDesc.getGuardingSuperCells()
                            );
                        }
                    }
                }
            );
            __syncthreads();

            forEachParticle(
                [&]( uint32_t const linearIdx, uint32_t const idx )
                {
                    if( hasValidParticleCtx[ idx ] )
                    {
                        /* copy attributes and activate particle*/
                        auto parDest = destFramePtr[ masterIdxCtx[ idx ] ][ linearIdx ];
                        auto parDestDeselect = deselect<
                            bmpl::vector2<
                                localCellIdx,
                                multiMask
                            >
                        >(parDest);
                        assign(parDestDeselect, srcFrame[ srcParticleIdxCtx[ idx ] ]);
                        parDest[ localCellIdx_ ] = lCellIdxCtx[ idx ];
                        parDest[ multiMask_ ] = 1;
                        /* counter[1] -> number of loaded particles
                         * this counter is evaluated on host side
                         * (check that loaded particles by this kernel == loaded particles from HDF5 file)*/
                        nvidia::atomicAllInc( &( counter[ 1 ] ) );
                    }
                }
            );
        }
    };
} //namespace kernel

/** Copy particles from big frame to PMacc frame structure
 *  (Opposite to ConcatListOfFrames)
 *
 * - convert a user-defined domainCellIdx to localCellIdx
 * - processed particles per block <= number of cells per superCell
 *
 * @param destSpecies particle species instance whose deviceBuffer is written
 * @param srcFrame device frame with particles (is used as source)
 * @param numParticles number of particles in srcFrame
 * @param chunkSize number of particles to process in one kernel call
 * @param localDomainCellOffset offset in cells to user-defined domain (@see wiki PIConGPU domain definitions)
 * @param domainCellIdxIdentifier the identifier for the particle domain cellIdx
 *                                that is calculated back to the local domain
 *                                with respect to localDomainCellOffset
 * @param cellDesc picongpu cellDescription
 * @param logLvl Log level used for information logging
 */
template<class T_LogLvl, class T_DestSpecies, class T_SrcFrame, class T_Space, class T_Identifier, class T_CellDescription>
HINLINE void splitIntoListOfFrames(
    T_DestSpecies& destSpecies,
    T_SrcFrame srcFrame,
    uint32_t numParticles,
    const uint32_t chunkSize,
    const T_Space& localDomainCellOffset,
    const T_Identifier domainCellIdxIdentifier,
    const T_CellDescription& cellDesc,
    const T_LogLvl& logLvl = T_LogLvl()
)
{
    constexpr uint32_t cellsInSuperCell = PMacc::math::CT::volume<typename T_CellDescription::SuperCellSize>::type::value;
    constexpr uint32_t worker = PMacc::traits::GetNumWorker<
                    cellsInSuperCell
                >::value;

    /* counter is used to apply for work, count used frames and count loaded particles
     * [0] -> offset for loading particles
     * [1] -> number of loaded particles
     * [2] -> number of used frames
     *
     * all values are zero after initialization
     */
    GridBuffer<uint32_t, DIM1> counterBuffer(DataSpace<DIM1>(3));

    const uint32_t iterationsForLoad = algorithms::math::float2int_ru(double(numParticles) / double(chunkSize));
    uint32_t leftOverParticles = numParticles;

    for (uint32_t i = 0; i < iterationsForLoad; ++i)
    {
        /* only load a chunk of particles per iteration to avoid blow up of frame usage */
        uint32_t currentChunkSize = std::min(leftOverParticles, chunkSize);
        log(logLvl, "load particles on device chunk offset=%1%; chunk size=%2%; left particles %3%") %
            (i * chunkSize) % currentChunkSize % leftOverParticles;
        PMACC_KERNEL(kernel::SplitIntoListOfFrames< worker >{})
            (
               algorithms::math::float2int_ru(double(currentChunkSize) / double(cellsInSuperCell)),
               worker
            )
            (counterBuffer.getDeviceBuffer().getDataBox(),
             destSpecies.getDeviceParticlesBox(), srcFrame,
             (int) numParticles,
             localDomainCellOffset,
             domainCellIdxIdentifier,
             cellDesc
             );
        destSpecies.fillAllGaps();
        leftOverParticles -= currentChunkSize;
    }

    counterBuffer.deviceToHost();
    log(logLvl, "wait for last processed chunk: %1%") % T_SrcFrame::getName();
    __getTransactionEvent().waitForFinished();

    log(logLvl, "used frames to load particles: %1%") % counterBuffer.getHostBuffer().getDataBox()[2];

    if ((uint64_t) counterBuffer.getHostBuffer().getDataBox()[1] != numParticles)
    {
        log(logLvl, "error load species | counter is %1% but should %2%") % counterBuffer.getHostBuffer().getDataBox()[1] % numParticles;
        throw std::runtime_error("Failed to load expected number of particles to GPU.");
    }
}

} //namespace operations
} //namespace particles
} //namespace PMacc
