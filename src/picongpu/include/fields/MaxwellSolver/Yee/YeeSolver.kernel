/**
 * Copyright 2013-2017 Axel Huebl, Heiko Burau, Rene Widera, Marco Garten
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */


#pragma once

#include "simulation_defines.hpp"
#include "mappings/threads/ForEachIdx.hpp"
#include "mappings/threads/IdxConfig.hpp"


namespace picongpu
{
namespace yeeSolver
{
using namespace PMacc;

    template<
        uint32_t T_worker,
        typename T_BlockDescription
    >
    struct KernelUpdateE
    {
        template<
            typename T_Curl,
            typename T_EBox,
            typename T_BBox,
            typename T_Mapping
        >
        DINLINE void operator()(
            const T_Curl& curl,
            T_EBox fieldE,
            T_BBox fieldB,
            T_Mapping mapper
        ) const
        {
            using namespace mappings::threads;

            constexpr uint32_t cellsPerSuperCell = PMacc::math::CT::volume< SuperCellSize >::type::value;
            constexpr uint32_t numWorker = T_worker;

            uint32_t const workerIdx = threadIdx.x;

            auto cachedB = CachedBox::create <
                0,
                typename T_BBox::ValueType
            >( T_BlockDescription() );

            nvidia::functors::Assign assign;
            DataSpace< simDim > const block( mapper.getSuperCellIndex( DataSpace<simDim >(blockIdx) ) );
            DataSpace< simDim > const blockCell = block * MappingDesc::SuperCellSize::toRT();

            auto fieldBBlock = fieldB.shift( blockCell );

            ThreadCollective<
                T_BlockDescription,
                numWorker
            > collective( workerIdx );

            collective(
                assign,
                cachedB,
                fieldBBlock
            );

            __syncthreads();

            constexpr float_X c2 = SPEED_OF_LIGHT * SPEED_OF_LIGHT;
            constexpr float_X dt = DELTA_T;

            ForEachIdx<
                IdxConfig<
                    cellsPerSuperCell,
                    numWorker
                >
            >{ workerIdx }(
                [&]( uint32_t const linearIdx, uint32_t const )
                {
                    /* cell index within the superCell */
                    DataSpace< simDim > const cellIdx = DataSpaceOperations< simDim >::template map< SuperCellSize >( linearIdx );

                    fieldE( blockCell + cellIdx ) += curl( cachedB.shift( cellIdx ) ) * c2 * dt;
                }
            );
        }
    };

    template<
        uint32_t T_worker,
        typename T_BlockDescription
    >
    struct KernelUpdateBHalf
    {
        template<
            typename T_Curl,
            typename T_EBox,
            typename T_BBox,
            typename T_Mapping
        >
        DINLINE void operator()(
            const T_Curl& curl,
            T_BBox fieldB,
            T_EBox fieldE,
            T_Mapping mapper
        ) const
        {
            using namespace mappings::threads;

            constexpr uint32_t cellsPerSuperCell = PMacc::math::CT::volume< SuperCellSize >::type::value;
            constexpr uint32_t numWorker = T_worker;

            uint32_t const workerIdx = threadIdx.x;

            auto cachedE = CachedBox::create <
                0,
                typename T_EBox::ValueType
            >( T_BlockDescription() );

            nvidia::functors::Assign assign;
            DataSpace< simDim > const block( mapper.getSuperCellIndex( DataSpace< simDim >( blockIdx ) ) );
            DataSpace< simDim > const blockCell = block * MappingDesc::SuperCellSize::toRT();

            auto fieldEBlock = fieldE.shift( blockCell );

            ThreadCollective<
                T_BlockDescription,
                numWorker
            > collective( workerIdx );

            collective(
                assign,
                cachedE,
                fieldEBlock
            );

            __syncthreads();

            constexpr float_X dt = DELTA_T;

            ForEachIdx<
                IdxConfig<
                    cellsPerSuperCell,
                    numWorker
                >
            >{ workerIdx }(
                [&]( uint32_t const linearIdx, uint32_t const )
                {
                    /* cell index within the superCell */
                    DataSpace< simDim > const cellIdx = DataSpaceOperations< simDim >::template map< SuperCellSize >( linearIdx );

                    fieldB( blockCell + cellIdx ) -= curl( cachedE.shift( cellIdx ) ) * float_X( 0.5 ) * dt;
                }
            );
        }
    };

} // yeeSolver

} // picongpu
