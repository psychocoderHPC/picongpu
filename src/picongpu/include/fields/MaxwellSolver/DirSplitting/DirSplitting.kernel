/**
 * Copyright 2013-2016 Heiko Burau, Rene Widera
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "pmacc_types.hpp"
#include <math/vector/Float.hpp>
#include "math/Vector.hpp"
#include <cuSTL/container/compile-time/SharedBuffer.hpp>
#include <cuSTL/algorithm/cudaBlock/Foreach.hpp>
#include <lambda/Expression.hpp>
#include <cuSTL/cursor/tools/twistVectorFieldAxes.hpp>

namespace picongpu
{

template<typename BlockDim, typename JSpaceTwist>
struct DirSplittingKernel
{
    typedef void result_type;

    typedef typename PMacc::math::CT::make_Vector<
        simDim,
        bmpl::integral_c<int,0>
    >::type ZeroVector;

    typedef typename PMacc::math::CT::Assign<
        ZeroVector,
        bmpl::integral_c<int,0>,
        bmpl::integral_c<int,-1>
    >::type Minus;

    typedef typename PMacc::math::CT::Assign<
        ZeroVector,
        bmpl::integral_c<int,0>,
        bmpl::integral_c<int,1>
    >::type Plus;

    PMACC_ALIGN(totalLength,int);
    DirSplittingKernel(int totalLength) : totalLength(totalLength) {}

    template<typename CursorE, typename CursorB, typename CursorJ, typename RCursorE, typename RCursorB >
    DINLINE void propagate(CursorE cursorE, CursorB cursorB, CursorJ cursorJ, RCursorE r_cursorE, RCursorB r_cursorB) const
    {
        typedef typename PMacc::math::CT::AssignIfInRange<
            ZeroVector,
            bmpl::integral_c<int,JSpaceTwist::y::value>,
            bmpl::integral_c<int,1>
        >::type jYDir;

        typedef typename PMacc::math::CT::AssignIfInRange<
            ZeroVector,
            bmpl::integral_c<int,JSpaceTwist::z::value>,
            bmpl::integral_c<int,1>
        >::type jZDir;

        const float_X deltaT = DELTA_T;
        const float_X constJE = (float_X(0.5)  / EPS0) * deltaT;

        const PMACC_AUTO(minus,Minus::toRT());
        const PMACC_AUTO(plus,Plus::toRT());
        float a_plus = (*cursorB(minus)).z() + (*cursorE(minus)).y(); /*- ( (*cursorJ).y() + ( *cursorJ(jYDir::toRT()) ).y() ) * constJE;*/
        float a_minus = (*cursorB(plus)).z() - (*cursorE(plus)).y(); /*+ ( (*cursorJ(plus)).y() + ( *cursorJ(plus + jYDir::toRT()) ).y() ) * constJE;*/
        float a_prime_plus = (*cursorB(minus)).y() - (*cursorE(minus)).z();/* + ( (*cursorJ).z() + ( *cursorJ(jZDir::toRT())).z() ) * constJE;*/
        float a_prime_minus = (*cursorB(plus)).y() + (*cursorE(plus)).z(); /*- ( (*cursorJ(plus)).z() + (*cursorJ(plus + jZDir::toRT()) ).z() ) * constJE;*/

        __syncthreads();

        (*cursorB).z() = 0.5f * (a_plus + a_minus);
        (*cursorE).y() = 0.5f * (a_plus - a_minus);
        (*cursorB).y() = 0.5f * (a_prime_plus + a_prime_minus);
        (*cursorE).z() = 0.5f * (a_prime_minus - a_prime_plus);

        __syncthreads();
    }

    template<typename CursorE, typename CursorB, typename CursorJ >
    DINLINE void operator()(CursorE globalE, CursorB globalB,CursorJ globalJ, CursorE old_globalE, CursorB old_globalB) const
    {

        typedef typename PMacc::math::CT::Assign<
            ZeroVector,
            bmpl::integral_c<int,0>,
            bmpl::integral_c<int,2>
        >::type XEntend;

        /* extend x size with 2 guards
         *
         * \todo: optimize cache size
         */
        typedef typename PMacc::math::CT::add<
            BlockDim,
            XEntend>::type CacheSize;

        typedef container::CT::SharedBuffer<float3_X, CacheSize, 0 > CacheE;
        typedef container::CT::SharedBuffer<float3_X, CacheSize, 1 > CacheB;
        CacheE cacheE;
        CacheB cacheB;

        using namespace lambda;
        DECLARE_PLACEHOLDERS();

        float3_X fieldE_old;
        float3_X fieldB_old;
        const DataSpace<simDim> threadIndex(threadIdx);
        int threadPos_x = threadIndex.x();

        algorithm::cudaBlock::Foreach<BlockDim> foreach;
        for (int x_offset = 0; x_offset < this->totalLength; x_offset += BlockDim::x::value)
        {
            PMACC_AUTO(globalShift,DataSpace<simDim>::create(0));
            globalShift.x() = -1 + x_offset;

            foreach(CacheE::Zone(), cacheE.origin(), globalE(globalShift), _1 = _2);
            foreach(CacheB::Zone(), cacheB.origin(), globalB(globalShift), _1 = _2);
            __syncthreads();

            const PMACC_AUTO(minus,Minus::toRT());
            const PMACC_AUTO(plus,Plus::toRT());

            DataSpace<simDim> cursorShift(plus);
            cursorShift.x()+=threadPos_x;

            for(uint32_t d = 1;d < simDim; ++d)
                cursorShift[d]+=threadIndex[d];

            BOOST_AUTO(cursorE, cacheE.origin()(cursorShift));
            BOOST_AUTO(cursorB, cacheB.origin()(cursorShift));

            if(threadPos_x == BlockDim::x::value - 1)
            {
                fieldE_old = *cursorE;
                fieldB_old = *cursorB;
            }
            if(threadPos_x == 0 && x_offset > 0)
            {
                *cursorE(minus) = fieldE_old;
                *cursorB(minus) = fieldB_old;
            }

            propagate(cursorE, cursorB, globalJ(globalShift+cursorShift),globalE(globalShift+cursorShift),globalB(globalShift+cursorShift));

            DataSpace<simDim> globalShiftTmp;
            globalShiftTmp.x() = x_offset;

            typedef zone::CT::SphericZone<BlockDim> BlockZone;
            foreach(BlockZone(), cacheE.origin()(plus), globalE(globalShiftTmp), _2 = _1);
            foreach(BlockZone(), cacheB.origin()(plus), globalB(globalShiftTmp), _2 = _1);

            __syncthreads();

            threadPos_x = BlockDim::x::value - 1 - threadPos_x;
        }
    }

};



template<typename BlockDim, int dir>
struct DirSplittingKernelX
{
    typedef void result_type;


    PMACC_ALIGN(totalLength,int);
    DirSplittingKernelX(int totalLength) : totalLength(totalLength) {}

    template<typename CursorE, typename CursorB, typename CursorJ, typename RCursorE, typename RCursorB >
    DINLINE void propagate0(CursorE cursorE, CursorB cursorB, CursorJ cursorJ, RCursorE r_cursorE, RCursorB r_cursorB) const
    {
        typedef DataSpace<DIM2> DS;

        DS z(DS::create(0));

        const float_X deltaT = DELTA_T;
        const float_X constJE = (float_X(0.5)  / EPS0) * deltaT;


        float jx1 =  ( (*cursorJ).x() + ( *cursorJ(z) ).x() ) * constJE;
        float jx2 =  ( (*cursorJ(DS(0,1))).x() + ( *cursorJ(DS(0,1)+z)).x() )  * constJE;

        float mjx1 =  ( (*cursorJ).x() + ( *cursorJ(DS(0,1)) ).x() ) * constJE;
        float mjx2 =  ( (*cursorJ(z)).x() + ( *cursorJ(z+DS(0,1))).x() )  * constJE;

        __syncthreads();

        (*cursorE).x() -= 0.5f * (jx1 + jx2);
        (*cursorB).z() -= 0.5f * (jx2 - jx1);

        (*cursorB).y() -= 0.5f * (mjx1 - mjx2);


        __syncthreads();
    }

    template<typename CursorE, typename CursorB, typename CursorJ, typename RCursorE, typename RCursorB >
    DINLINE void propagate1(CursorE cursorE, CursorB cursorB, CursorJ cursorJ, RCursorE r_cursorE, RCursorB r_cursorB) const
    {
        typedef DataSpace<DIM2> DS;

        DS z(DS::create(0));

        const float_X deltaT = DELTA_T;
        const float_X constJE = (float_X(0.5)  / EPS0) * deltaT;


        float jy1 =  ( (*cursorJ).y() + ( *cursorJ(z) ).y() ) * constJE;
        float jy2 =  ( (*cursorJ(DS(1,0))).y() + ( *cursorJ(DS(1,0)+z)).y() )  * constJE;

        float mjy1 =  ( (*cursorJ).y() + ( *cursorJ(DS(1,0)) ).y() ) * constJE;
        float mjy2 =  ( (*cursorJ(z)).y() + ( *cursorJ(z+DS(1,0))).y() )  * constJE;

        __syncthreads();

        (*cursorE).y() -= 0.5f * (jy1 + jy2);
        (*cursorB).z() -= 0.5f * (jy1 - jy2);

        (*cursorB).x() -= 0.5f * (mjy2 - mjy1);


        __syncthreads();
    }

    template<typename CursorE, typename CursorB, typename CursorJ, typename RCursorE, typename RCursorB >
    DINLINE void propagate2(CursorE cursorE, CursorB cursorB, CursorJ cursorJ, RCursorE r_cursorE, RCursorB r_cursorB) const
    {
        typedef DataSpace<DIM2> DS;

        DS z(DS::create(0));

        const float_X deltaT = DELTA_T;
        const float_X constJE = (float_X(0.5)  / EPS0) * deltaT;


        float jz1 =  ( (*cursorJ).z() + ( *cursorJ(DS(0,1)) ).z() ) * constJE;
        float jz2 =  ( (*cursorJ(DS(1,0))).z() + ( *cursorJ(DS(1,0)+DS(0,1))).z() )  * constJE;

        float mjz1 =  ( (*cursorJ).z() + ( *cursorJ(DS(1,0)) ).z() ) * constJE;
        float mjz2 =  ( (*cursorJ(DS(0,1))).z() + ( *cursorJ(DS(0,1)+DS(1,0))).z() )  * constJE;

        __syncthreads();

        (*cursorE).z() -= 0.5f * (jz1 + jz2);
        (*cursorB).y() -= 0.5f * (jz2 - jz1);

        (*cursorB).x() -= 0.5f * (mjz1 - mjz2);


        __syncthreads();
    }

    template<typename CursorE, typename CursorB, typename CursorJ >
    DINLINE void operator()(CursorE globalE, CursorB globalB,CursorJ globalJ, CursorE old_globalE, CursorB old_globalB) const
    {

        typedef container::CT::SharedBuffer<float3_X, BlockDim, 0 > CacheE;
        typedef container::CT::SharedBuffer<float3_X, BlockDim, 1 > CacheB;
        CacheE cacheE;
        CacheB cacheB;

        using namespace lambda;
        DECLARE_PLACEHOLDERS();

        float3_X fieldE_old;
        float3_X fieldB_old;
        const DataSpace<simDim> threadIndex(threadIdx);
        int threadPos_x = threadIndex.x();

        algorithm::cudaBlock::Foreach<BlockDim> foreach;
        //for (int x_offset = 0; x_offset < this->totalLength; x_offset += BlockDim::x::value)
        {
            PMACC_AUTO(globalShift,DataSpace<simDim>::create(0));
            //globalShift.x() = x_offset;

            foreach(CacheE::Zone(), cacheE.origin(), globalE(globalShift), _1 = _2);
            foreach(CacheB::Zone(), cacheB.origin(), globalB(globalShift), _1 = _2);
            __syncthreads();


            DataSpace<simDim> cursorShift;
            //cursorShift.x()+=threadPos_x;

            for(uint32_t d = 0;d < simDim; ++d)
                cursorShift[d]+=threadIndex[d];

            BOOST_AUTO(cursorE, cacheE.origin()(cursorShift));
            BOOST_AUTO(cursorB, cacheB.origin()(cursorShift));

            if(dir==0)
                propagate0(cursorE, cursorB, globalJ(globalShift+cursorShift),globalE(globalShift+cursorShift),globalB(globalShift+cursorShift));
            else if(dir==1)
                propagate1(cursorE, cursorB, globalJ(globalShift+cursorShift),globalE(globalShift+cursorShift),globalB(globalShift+cursorShift));
            else
                propagate2(cursorE, cursorB, globalJ(globalShift+cursorShift),globalE(globalShift+cursorShift),globalB(globalShift+cursorShift));

            DataSpace<simDim> globalShiftTmp;
            //globalShiftTmp.x() = x_offset;

            typedef zone::CT::SphericZone<BlockDim> BlockZone;
            foreach(BlockZone(), cacheE.origin(), globalE(globalShiftTmp), _2 = _1);
            foreach(BlockZone(), cacheB.origin(), globalB(globalShiftTmp), _2 = _1);

            __syncthreads();

            //threadPos_x = BlockDim::x::value - 1 - threadPos_x;
        }
    }

};

} // picongpu
