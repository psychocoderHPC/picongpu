/**
 * Copyright 2013-2017 Axel Huebl, Heiko Burau, Rene Widera, Felix Schmitt
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "simulation_defines.hpp"
#include "particles/Particles.hpp"
#include "memory/boxes/DataBox.hpp"
#include "memory/boxes/PitchedBox.hpp"
#include "dimensions/DataSpaceOperations.hpp"

#include "simulation_defines.hpp"
#include "plugins/radiation/parameters.hpp"
#include "particles/operations/SetAttributeToDefault.hpp"
#include "compileTime/conversion/ResolveAndRemoveFromSeq.hpp"
#include "particles/startPosition/MacroParticleCfg.hpp"
#include "particles/traits/GetDensityRatio.hpp"
#include "nvidia/atomic.hpp"
#include "memory/shared/Allocate.hpp"
#include "memory/CtxArray.hpp"
#include "mappings/threads/ForEachIdx.hpp"
#include "mappings/threads/IdxConfig.hpp"

namespace picongpu
{

using namespace PMacc;

/** Returns the electron density.
 *  That means:
 *     The REAL number of electrons density in units of volume**-3,
 *       normed to UNIT_LENGHT**3
 *     That is NOT the macro electron density.
 *
 * @param offset The gpu offset (left top front cell in 3D)
 * @param cellIdx the current cell on this gpu
 * @return a float_X which stands for the real number of electrons per volume
 */
template< typename T_Species, typename T_DensityProfile>
DINLINE float_X calcRealDensity(T_DensityProfile& densityFunctor,
                                const DataSpace<simDim>& totalGpuCellIdx)
{
    PMACC_CASSERT_MSG(Please_deselect_densityProfileInitMethod_for_your_species_or_set_BASE_DENSITY_to_a_value_greater_than_0, ((BASE_DENSITY) > 0.0f));

    const float_X densityRatioOfSpecies = traits::GetDensityRatio<T_Species>::type::getValue();

    const float_X value = densityFunctor(totalGpuCellIdx) * BASE_DENSITY * densityRatioOfSpecies;
    return value;
}

template< uint32_t T_worker, typename T_Species >
struct KernelFillGridWithParticles
{
    template<typename T_DensityProfile, typename T_PositionFunctor, typename ParBox, class Mapping>
    DINLINE void operator()(
        T_DensityProfile densityFunctor,
        T_PositionFunctor positionFunctor,
        DataSpace<simDim> totalGpuCellOffset,
        ParBox pb,
        Mapping mapper) const
    {
        using namespace mappings::threads;

        constexpr uint32_t frameSize = PMacc::math::CT::volume< SuperCellSize >::type::value;
        constexpr uint32_t numWorker = T_worker;

        uint32_t const workerIdx = threadIdx.x;

        typedef typename ParBox::FramePtr FramePtr;
        DataSpace< simDim > const superCells( mapper.getGridSuperCells() );

        PMACC_SMEM( frame, FramePtr );
        PMACC_SMEM( finished, int );

        DataSpace< simDim > const superCellIdx(
            mapper.getSuperCellIndex( DataSpace<simDim >( blockIdx ) )
        );

        /* do not add particle to guarding super cells */
        for( uint32_t d = 0; d < simDim; ++d )
            if( superCellIdx[ d ] == 0 || superCellIdx[ d ] == superCells[ d ] - 1) return;

        /* offset of the superCell relative to the local domain [cells] (without guarding cells) */
        DataSpace< simDim > const superCellOffset(
            ( superCellIdx - mapper.getGuardingSuperCells() )
            * SuperCellSize::toRT()
        );


        using ParticleDomCfg = IdxConfig<
            frameSize,
            numWorker
        >;

        ForEachIdx< ParticleDomCfg > forEachParticle( workerIdx );

        /* weighting for all particles in a cell */
        memory::CtxArray<
            float_X,
            ParticleDomCfg
        >
        macroWeightingCtx( 0.0 );

        memory::CtxArray<
            uint32_t,
            ParticleDomCfg
        >
        numParsPerCellCtx( 0 );

        /* create for virtual thread a own position functor instance */
        memory::CtxArray<
            T_PositionFunctor,
            ParticleDomCfg
        >
        positionFunctorCtx( positionFunctor );


        ForEachIdx<
            IdxConfig<
                1,
                numWorker
            >
        > onlyMaster{ workerIdx };

        /* reset shared memory flag if a virtual worker needs to create a particle */
        onlyMaster(
            [&]( uint32_t const, uint32_t const )
            {
                finished = 1;
            }
        );

        __syncthreads();

        memory::CtxArray<
            uint32_t,
            ParticleDomCfg
        > const
        totalNumParsPerCellCtx(
            workerIdx,
            [&]( uint32_t const linearIdx, uint32_t const idx )
            {
                /* cell index within the superCell */
                DataSpace< simDim > const cellIdx = DataSpaceOperations< simDim >::template map< SuperCellSize >( linearIdx );

                /* cell offset to the begin of the simulation */
                DataSpace< simDim > const totalCellOffset = totalGpuCellOffset + superCellOffset + cellIdx;
                float_X const realDensity = calcRealDensity< T_Species >( densityFunctor, totalCellOffset );

                const float_X realParticlesPerCell = realDensity * CELL_VOLUME;



                positionFunctorCtx[ idx ].init( totalCellOffset );
                // decrease number of macro particles, if weighting would be too small
                particles::startPosition::MacroParticleCfg makroCfg =
                    positionFunctorCtx[ idx ].mapRealToMacroParticle( realParticlesPerCell );
                macroWeightingCtx[ idx ] = makroCfg.weighting;
                numParsPerCellCtx[ idx ] = makroCfg.numParticlesPerCell;

                if( numParsPerCellCtx[ idx ] > 0)
                    nvidia::atomicAllExch( &finished, 0 ); //one or more cells have particles to create

                return numParsPerCellCtx[ idx ];
            }
        );

        __syncthreads();

        if( finished == 1 )
            return; // if there is no particle which has to be created

        onlyMaster(
            [&]( uint32_t const, uint32_t const )
            {
                frame = pb.getEmptyFrame();
                pb.setAsLastFrame( frame, superCellIdx );
            }
        );

        // distribute the particles within the cell
        do
        {

            __syncthreads();

            onlyMaster(
                [&]( uint32_t const, uint32_t const )
                {
                    finished = 1;
                }
            );

            __syncthreads();

            forEachParticle(
                [&]( uint32_t const linearIdx, uint32_t const idx )
                {
                    if( numParsPerCellCtx[ idx ] > 0 )
                    {
                        floatD_X const pos = positionFunctorCtx[ idx ] ( totalNumParsPerCellCtx[ idx ] - numParsPerCellCtx[ idx ] );
                        auto particle = frame[ linearIdx ];

                        /** we now initialize all attributes of the new particle to their default values
                         *   some attributes, such as the position, localCellIdx, weighting or the
                         *   multiMask (\see AttrToIgnore) of the particle will be set individually
                         *   in the following lines since they are already known at this point.
                         */
                        {
                            using FrameType = typename ParBox::FrameType;
                            using ParticleAttrList = typename FrameType::ValueTypeSeq;
                            using AttrToIgnore = bmpl::vector4<
                                position<>,
                                multiMask,
                                localCellIdx,
                                weighting
                            >;
                            using ParticleCleanedAttrList = typename ResolveAndRemoveFromSeq<
                                ParticleAttrList,
                                AttrToIgnore
                            >::type;

                            algorithms::forEach::ForEach<
                                ParticleCleanedAttrList,
                                SetAttributeToDefault< bmpl::_1 >
                            > setToDefault;
                            setToDefault( forward( particle ) );
                        }
                        particle[ position_ ] = pos;
                        particle[ multiMask_ ] = 1;
                        particle[ localCellIdx_ ] = linearIdx;
                        particle[ weighting_ ] = macroWeightingCtx[ idx ];

#if( ENABLE_RADIATION == 1 )
#   if( RAD_MARK_PARTICLE>1 ) && ( RAD_ACTIVATE_GAMMA_FILTER==0 )
                        particle[ radiationFlag_ ] = (bool)(rng() < (1.0 / (float_32) RAD_MARK_PARTICLE));
#   endif
#   if( RAD_ACTIVATE_GAMMA_FILTER!=0 )
                        particle[ radiationFlag_ ] = (bool)(false);
#   endif
#endif
                        numParsPerCellCtx[ idx ]--;
                        if( numParsPerCellCtx[ idx ] > 0 )
                            atomicExch( &finished, 0 ); //one or more cell has particles to create
                    }
                }
            );

            __syncthreads();

            onlyMaster(
                [&]( uint32_t const, uint32_t const )
                {
                    if( finished == 0 )
                    {
                        frame = pb.getEmptyFrame();
                        pb.setAsLastFrame( frame, superCellIdx );
                    }
                }
            );
        }
        while( finished == 0 );
    }
};

}
