/**
 * Copyright 2014 Rene Widera
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */


#pragma once

#include "types.h"
#include "simulation_types.hpp"
#include "dimensions/DataSpaceOperations.hpp"
#include "math/Vector.hpp"

namespace picongpu
{

using namespace PMacc;

template<class T_CounterBox, class T_DestBox, class T_SrcFrame, class T_Space, class T_Mapping>
__global__ void copySpeciesGlobal2Local(T_CounterBox counter, T_DestBox destBox, T_SrcFrame srcFrame,
                                        const int maxParticles,
                                        T_Space gpuCellOffset, T_Mapping mapper)
{
    using namespace PMacc::particles::operations;

    typedef T_SrcFrame SrcFrameType;
    typedef typename T_DestBox::FrameType DestFrameType;
    typedef T_Mapping Mapping;
    typedef typename Mapping::SuperCellSize SuperCellSize;
    const int cellsInSuperCell = PMacc::math::CT::volume<SuperCellSize>::type::value;

    __shared__ DestFrameType * destFramePtr[cellsInSuperCell];
    __shared__ int linearSuperCellIds[cellsInSuperCell];
    __shared__ int hdf5ParticleOffset;

    const int linearThreadIdx = threadIdx.x;

    __syncthreads(); /*wait that all shared memory is initialized*/

    const DataSpace<Mapping::Dim> superCellsCount(mapper.getGridSuperCells() - mapper.getGuardingSuperCells()*2);

    if (threadIdx.x == 0)
    {
        /* apply for work*/
        hdf5ParticleOffset = atomicAdd(&(counter[0]), cellsInSuperCell);
    }
    destFramePtr[linearThreadIdx] = NULL;
    linearSuperCellIds[linearThreadIdx] = -1;

    __syncthreads();

    const int globalParticleId = hdf5ParticleOffset + linearThreadIdx;
    const bool hasValidParticle = globalParticleId < maxParticles;
    DataSpace<Mapping::Dim> superCellIdx;
    lcellId_t lCellIdx = INV_LOC_IDX;

    if (hasValidParticle)
    {
        DataSpace<Mapping::Dim> globalCellIdx = srcFrame[globalParticleId][globalCellIdx_];
        globalCellIdx -= gpuCellOffset;
        superCellIdx = globalCellIdx / SuperCellSize::toRT();
        linearSuperCellIds[linearThreadIdx] = DataSpaceOperations<Mapping::Dim>::map(superCellsCount, superCellIdx);
        DataSpace<simDim> inSuperCell(globalCellIdx - superCellIdx * SuperCellSize::toRT());
        lCellIdx = DataSpaceOperations<Mapping::Dim>::template map<SuperCellSize>(inSuperCell);
    }
    __syncthreads();

    int masterIdx = linearThreadIdx - 1;
    const int myLinearSuperCellId = linearSuperCellIds[linearThreadIdx];

    if (hasValidParticle)
    {
        for (; masterIdx >= 0; --masterIdx)
        {
            if (myLinearSuperCellId != linearSuperCellIds[masterIdx])
            {
                break;
            }
        }
        ++masterIdx;

        /*load empty frame*/
        if ((masterIdx == linearThreadIdx))
        {
            atomicAdd(&(counter[2]), 1);
            destFramePtr[linearThreadIdx] = &destBox.getEmptyFrame();
            destBox.setAsLastFrame(*(destFramePtr[linearThreadIdx]), superCellIdx + mapper.getGuardingSuperCells());
        }
    }
    __syncthreads();

    if (hasValidParticle)
    {
        PMACC_AUTO(parDest, (*(destFramePtr[masterIdx]))[linearThreadIdx]);
        parDest[localCellIdx_] = lCellIdx;
        parDest[multiMask_] = 1;
        PMACC_AUTO(parDestDeselect, deselect<bmpl::vector2<localCellIdx, multiMask> >(parDest));
        assign(parDestDeselect, srcFrame[globalParticleId]);
        atomicAdd(&(counter[1]), 1);
    }
    __syncthreads();
}

} //namespace picongpu
