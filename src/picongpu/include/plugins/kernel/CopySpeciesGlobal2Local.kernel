/**
 * Copyright 2014 Rene Widera
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */


#pragma once

#include "types.h"
#include "simulation_types.hpp"
#include "dimensions/DataSpaceOperations.hpp"
#include "math/Vector.hpp"

namespace picongpu
{

using namespace PMacc;

template<class T_CounterBox, class T_DestBox, class T_SrcFrame, class T_Space, class T_Mapping>
__global__ void copySpeciesGlobal2Local(T_CounterBox counter, T_DestBox destBox, T_SrcFrame srcFrame,
                                        const int maxParticles,
                                        T_Space gpuCellOffset, T_Mapping mapper)
{
    using namespace PMacc::particles::operations;

    typedef T_SrcFrame SrcFrameType;
    typedef typename T_DestBox::FrameType DestFrameType;
    typedef T_Mapping Mapping;
    typedef typename Mapping::SuperCellSize SuperCellSize;
    const int cellsInSuperCell = PMacc::math::CT::volume<SuperCellSize>::type::value;

    typedef DestFrameType* DestFramePtr;
    __shared__ DestFramePtr destFramePtr[cellsInSuperCell];
    __shared__ int linearSuperCellIds[cellsInSuperCell];
    __shared__ int hdf5ParticleOffset;


    const int linearThreadIdx = threadIdx.x;

    __syncthreads(); /*wait that all shared memory is initialized*/

    const DataSpace<Mapping::Dim> superCellsCount(mapper.getGridSuperCells() - mapper.getGuardingSuperCells()*2);
    if (linearThreadIdx == 0)
    {
        /* apply for work for the full block*/
        hdf5ParticleOffset = atomicAdd(&(counter[0]), cellsInSuperCell);
    }
    destFramePtr[linearThreadIdx] = NULL;
    linearSuperCellIds[linearThreadIdx] = -1;

    __syncthreads();

    const int globalParticleId = hdf5ParticleOffset + linearThreadIdx;
    const bool hasValidParticle = globalParticleId < maxParticles;
    DataSpace<Mapping::Dim> superCellIdx;
    lcellId_t lCellIdx = INV_LOC_IDX;
    int myLinearSuperCellId = -1;

    if (hasValidParticle)
    {
        DataSpace<Mapping::Dim> globalCellIdx = srcFrame[globalParticleId][globalCellIdx_];
        globalCellIdx -= gpuCellOffset;
        superCellIdx = globalCellIdx / SuperCellSize::toRT();
        myLinearSuperCellId = DataSpaceOperations<Mapping::Dim>::map(superCellsCount, superCellIdx);
        linearSuperCellIds[linearThreadIdx] = myLinearSuperCellId;
        DataSpace<simDim> inSuperCell(globalCellIdx - superCellIdx * SuperCellSize::toRT());
        lCellIdx = DataSpaceOperations<Mapping::Dim>::template map<SuperCellSize>(inSuperCell);
    }
    __syncthreads();

    int masterIdx = linearThreadIdx - 1;

    if (hasValidParticle)
    {
        /* search master thread index */
        while (masterIdx >= 0)
        {
            if (myLinearSuperCellId != linearSuperCellIds[masterIdx])
            {
                break;
            }
            --masterIdx;
        }
        ++masterIdx;
        /* load empty frame if thread is the master*/
        if ((masterIdx == linearThreadIdx))
        {
            atomicAdd(&(counter[2]), 1);
            DestFramePtr tmpFrame;
            tmpFrame = &(destBox.getEmptyFrame());
            destFramePtr[linearThreadIdx] = tmpFrame;
            destBox.setAsFirstFrame(*tmpFrame, superCellIdx + mapper.getGuardingSuperCells());
        }
    }
    __syncthreads();

    if (hasValidParticle)
    {
        /* copy attributes and activate particle*/
        PMACC_AUTO(parDest, (*(destFramePtr[masterIdx]))[linearThreadIdx]);
        parDest[localCellIdx_] = lCellIdx;
        parDest[multiMask_] = 1;
        PMACC_AUTO(parDestDeselect, deselect<bmpl::vector2<localCellIdx, multiMask> >(parDest));
        assign(parDestDeselect, srcFrame[globalParticleId]);
        /* this counter is evaluated on host side
         * (check that loaded particles by this kernel == loaded particles from HDF5 file)*/
        atomicAdd(&(counter[1]), 1);
    }
}

} //namespace picongpu
